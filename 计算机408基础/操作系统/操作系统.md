# 操作系统
# 目录

[TOC]





# 前言

参考资料：南京大学蒋炎岩操作系统wiki：[操作系统：设计与实现 (2022 春季学期) (jyywiki.cn)](https://jyywiki.cn/OS/2022/)

课程视频地址：【王道计算机考研 操作系统】 https://www.bilibili.com/video/BV1YE411D7nH/?share_source=copy_web&vd_source=1bbc8a9be9ea748de8b1d19c0446cafd

参考阅读：现代操作系统

# 第一章节 操作系统概述

## 1.1什么是操作系统？

操作系统 operation system，是管理计算机硬件和软件资源的计算机程序，是建立在计算机硬件上的第一层程序。

计算机系统的构成：

![image-20230916174356761](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916174356761.png)

操作系统是一个什么样的角色？操作系统为应用程序提供接口，也为用户提供接口，实际上操作系统是一个管理者的角色。操作系统是系统资源的管理者，向上层提供方便易用的服务



操作系统演化过程：

![image-20230916175004210](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916175004210.png)

## 1.2操作系统的目标和功能

OS作为计算机系统资源的管理者：

* 处理机管理
  * 进程控制
  * 进程同步
  * 进程通信
  * 调度
* 存储器管理
  * 内存分配
  * 内存保护
  * 地址映射
  * 内存扩充
* IO设备管理
  * 缓冲管理
  * 设备分配
  * 设备处理
* 文件管理
  * 文件存储空间的管理
  * 目录管理
  * 文件的读写管理和保护



![image-20230916191309944](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916191309944.png)

## 1.3操作系统的四个特征

四个特征包括：并发，共享，虚拟，异步，其中并发和共享是两个最基本的特征，二者互为存在条件

**特征之一：并发**

并发是指两个或多个事件在统一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的。

易混淆概念之并行：指两个或多个事件在同一时刻内同时发生。

操作系统的并发性是指计算机系统中**同时**运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。

**注意**：

单核CPU 同一时刻只能执行一个程序，各个程序只能并发运行；

多核CPU 同一时刻可以同时执行多个程序，多个程序可以并行执行。

**特征之二：共享**

共享即资源共享：是指系统中的资源可供内存中多个并发执行的进程共同使用。

有两种资源共享方式：

- 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只运行一个进程访问该资源。
- 同时共享方式：系统中的某些资源，允许一个时间段内有多个进程"同时"对他们进行访问。



**并发和共享的关系**

并发性指计算机系统中同时存在着多个运行着的程序。

共享性是指系统中的资源可供内存中多个并发执行的进程的共同使用

eg：使用qq发送文件A，同时使用微信发送文件B

1. 两个进程正在并发的执行，这是并发性，如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义
2. 需要共享的访问硬盘资源，这是共享性，如果失去共享性，则QQ和vx无法同时的访问硬盘资源，就无法实现同时发送文件，也就无法并发
3. 所以说并发性和共享性互为存在条件

**特征之三：虚拟**

虚拟是指吧一个物理上的实体变为若干个逻辑上的对应物，物理实体是实际存在的，而逻辑对应物是用户感受到的。

虚拟技术：

- 空分复用技术：如虚拟存储器技术
- 时分复用技术：如虚拟处理器，虚拟技术中的**时分复用**技术，微观上处理机在各个微小的时间片内交替的为各个进程服务。
- 如果失去了并发性，则一个时间段内系统中只存在一个程序，那么就是失去虚拟性的意义了，因此，没有并发性，就没有虚拟性。

**特征之四：异步**

异步性是指在多道程序设计环境下，系统中每道程序的推进时间、多道程序间的执行顺序以及完成每道程序所需的时间由于受运行环境的影响都是不确定的、不可预知的。

多道程序并发执行环境中，进程由于受到资源限制或其他因素的影响，其执行往往不是一贯到底，而是呈现出“走走停停"的特征。同一程序多次执行相同数据，若不采取任何措施，受运行环境的影响，可能得到不同运行结果。



![image-20230916195017329](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916195017329-1694865018552-1.png)

## 1.4 操作系统的发展与分类

**手工操作阶段**

![image-20230916195811071](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916195811071.png)

**批处理阶段：单道批处理系统**

![image-20230916200017908](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916200017908.png)

**批处理阶段：多道批处理系统**

![image-20230916203823752](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916203823752.png)

**分时操作系统**

![image-20230916204112950](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916204112950.png)

**实时操作系统**

![image-20230916204239986](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916204239986.png)



![image-20230916204352099](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916204352099.png)

## 1.5 操作系统的运行机制

**内核程序和应用程序：**

普通程序员写的程序就是应用程序

微软苹果等负责实现操作系统，他们写的是内核程序，有很多内核程序组成了操作系统内核，kernel。

内核是操作系统最重要最核心的部分，也是最接近硬件的部分，甚至可以说，一个操作系统只要有内核就足够了。

**特权指令和非特权指令**

操作系统内核作为管理者，有时会让CPU 执行一些特权指令，如：内存清零指令，这些指令只允许操作系统内核来使用。

应用程序只能使用非特权指令，如加法减法

在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断其类型。

**内核态和用户态**

CPU能判断出指令类型，但是他怎么区分此时正在运行的是内核程序或者应用程序呢？

CPU有两种状态，内核态和用户态

处在内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令

处在用户态时，说明此时正在运行的是应用程序，此时可以执行非特权指令

在CPU中有一个寄存器叫**程序状态字寄存器PSW**,其中有个二进制位，1表示内核态，0表示用户态

别名：内核态=核心态=管态  用户态=目态

![image-20230916210648895](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230916210648895.png)

## 1.6中断和异常

CPU上会运行两种程序，一种是操作系统内核，一种是应用程序。

在正常情况下操作系统内核会把CPU的使用权主动让给应用程序，**中断**是让操作系统内核夺回CPU使用权的唯一途径，中断会让CPU 由用户态变为内核态，使操作系统重新夺回对CPU的控制权。

从内核态切换到用户态：执行一条特权指令，修改PSW的标志位为用户态，操作系统让出CPU的控制权。

从用户态切换到内核态：由中断引发，硬件自动完成变态的过程，触发中断信号意味着操作系统将强行夺回对CPU的使用权。

中断的两种内型：

- 内中断：与当前执行的指令有关，中断信号来源于CPU内部
- 外中断：与当前执行的指令无关，中断信号来源于CPU外部

**内中断**

例子1：试图在用户态下执行特权指令

例子2：执行除法指令时发现除数为0

例子3：有时候应用程序想请求操作系统内核的服务时，此时会执行一条特殊的指令，**陷入指令**，该指令会引发一个内部中断信号。

陷入指令不是特权指令，执行陷入指令，意味应用程序主动的将CPU控制权还给操作系统内核，系统调用就是通过陷入指令完成的。

**外中断**

例子1：时钟中断，有时钟部件发来的中断信号，时钟部件每隔一段时间（如50ms）会给CPU发送一个时钟中断信号，控制CPU不断地切换应用程序执行

例子2：IO中断，由输入输出设备发出的中断信号

每一条指令执行结束，CPU都会例行检查受否有外中断信号。

![image-20230917155025644](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917155025644.png)

**中断机制的基本原理**

不同的中断信号，需要用不同的中断处理程序来处理，当CPU 检测到中断信号后，会根据中断信号的类型去查询"中断向量表"，以此来找到相应的中断处理程序在内存中的存放位置。

![image-20230917155516634](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917155516634.png)

![image-20230917155801421](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917155801421.png)

## 1.7系统调用

- 什么是系统调用？
- 系统调用和库函数的区别
- 为什么系统调用是必须的？
- 什么功能要用系统调用实现？
- 系统调用的过程。

**什么是系统调用？**

系统调用是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务。

**系统调用和库函数的区别？**

有些库函数封装了系统调用的接口，是编程人员在进行一些必须系统调用时可以通过调用库函数更方便的完成。

**为什么系统调用是必须的？**

多个进程并发运行，同时访问类似打印机这种需要互斥共享的资源时，想要实现对共享资源的互斥访问，需要操作系统内核来对共享资源进行统一管理。

凡是需要对共享资源进行操作，都必须通过系统调用的方式向操作系统内核发出请求，有内核来完成，保证系统的稳定性和安全性。

系统调用按功能分类：

- 设备管理：完成设备的请求释放启动等
- 文件管理：完成文件的读写 创建 删除
- 进程控制：完成进程的创建 撤销 阻塞 唤醒 等
- 进程通信：完成进程之间的消息传递/信号传递
- 内存管理：完成内存的分配 回收

**系统调用的过程**

![image-20230917162718921](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917162718921.png)

![image-20230917162943896](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917162943896.png)



## 1.8操作系统体系结构

总览：

- 大内核
- 微内核
- 分层结构
- 模块化
- 外核

![image-20230917163812837](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917163812837.png)

![image-20230917164552740](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917164552740.png)

![image-20230917191841424](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917191841424.png)

**操作系统引导**

什么是操作系统引导？在电脑开机的时候，能够让操作系统运行起来。

![image-20230917192348603](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917192348603.png)

**虚拟机**

![image-20230917193037221](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917193037221.png)

两种虚拟机管理程序的对比：

![image-20230917193545700](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917193545700.png)

# 第二章节 进程

## 2.1进程的概念，组成，特征

程序：是**静态**的，就是存放在磁盘的可执行文件，是一系列指令集和，也可以说是**静态的代码文件**

进程：process，是动态的，是**程序的一次执行过程**。即使同一个程序多次执行也会对应多个进程。

问题：操作系统如何区分各个进程的？

当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的身份证号：PID processID，进程ID

### PCB

操作系统引入进程的主要目的在于清晰刻画系统的内在活动规律，有效调度和管理进入内存的程序。从理论角度上看，进程是对运行程序活动规律的抽象；从实现角度上看，进程实体由**程序段、数据段和进程控制块**(Process Control Block,PCB)组成

操作系统要记录PID、进程所属用户ID（UID），记录给进程分配了那些资源，如内存、IO，记录进程的运行情况，如CPU使用时间 磁盘使用时间 网络 流量，这些信息都被存储到数据结构PCB中，进程控制块。 每创建一个进程就会对应的创建PCB。

程序段：程序的代码、指令序列

数据段：运行过程中产生的各种数据，比如程序中定义的各种变量

### 进程的特征

(1)   动态性。进程实质是程序的一次执行过程。进程由创建而产生，由调度而执行，由 撤销而消亡。因此，进程具有一个生命周期，它是操作系统中最活跃的部分。在进程生命周 期中，进程的状态不断发生改变。动态性是进程最基本的特征，也是它区分于程序的最重要 特征。

(2)   共享性。操作系统与多个用户的进程共同使用计算机系统中的资源。系统中的硬 件和软件资源不再为某个进程所独占，而是供多个用户进程共同使用。

(3)   并发性。多个进程实体同存于内存中，且在一段时间内同时运行。对于单CPU系 统而言，各个进程轮流切换地使用CPU。进程的执行过程可被中断。进程在执行完一条指 令后、执行下一条指令前可能被迫让出处理机，由其他进程执行若干条指令后才能再次获得 处理机，从断点处继续执行。

进程的并发性提高了系统的资源利用率和作业吞吐量，它也是进程最重要特征之一。 并发性和共享性是互为存在条件的。共享性是以进程的并发性为条件的，若系统不允许进程并发执行，自然不存在资源共享问题。若系统不能对资源共享实施有效的管理，必将影响到进程的并发执行，甚至根本无法并发执行。

(4)   独立性。进程是一个能独立运行的基本单位，只有进程才能向操作系统申请资源， 凡是未建立进程的程序都不能作为独立运行单位参与CPU的分配。

注意：在没有引入线程技术的系统中，**进程是CPU调度的基本单位**；引入线程后，**线程 是CPU调度的基本单位**，进程不再是CPU调度的基本单位，但仍然是其他**系统资源分配的基本单位**。

(5)   异步性。并发执行进程之间存在着相互制约关系。进程在执行的关键点上可能需要与其他进程相互等待或互通消息，这导致进程按各自独立的、不可预知的速度向前推进， 造成进程间的**执行顺序不确定**，具有异步性。

![image-20230917205253121](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917205253121.png)

## 2.2进程状态的转换

![image-20230917210033945](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917210033945.png)

### 进程的状态

![image-20230917210329025](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917210329025.png)

### 进程的组织方式

#### 链接方式

![image-20230917210529029](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917210529029.png)

#### 索引方式

![image-20230917210608652](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917210608652.png)



![image-20230917210649093](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917210649093.png)

## 2.3进程控制

### 什么是进程控制？

进程控制的主要职责是对系统中的全部进程实施有效的管理，其功能包括进程的创建、进程的执行、进程的撤销、进程的阻塞与唤醒以及**进程状态转换**。这些功能一般均由操作系统内核实现。

### 如何实现进程控制？

原语  不可分割性  原子性

![image-20230917212748221](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917212748221.png)

### 如何实现原子性？

![image-20230917213041156](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917213041156.png)

### 进程中控制相关的原语

内核中用于控制进程的原语通常有以下6种。

(1)创建原语。当创建一个新进程时，系统调用创建原语，为新建进程分配一个工作区 和建立一个进程控制块，并置该进程为就绪状态。

(2)撤销原语。一个进程执行完毕后，系统调用撤销原语，收回该进程的工作区和进程控制块。

(3) 阻塞原语。进程运行过程中等待某事件发生，例如等待和某进程通信、等待其他进程释放占有的资源等，该进程自己调用阻塞原语，把进程状态改为阻塞状态。

(4) 唤醒原语。当进程等待的事件发生时，由其他进程执行唤醒原语，把处于阻塞状态 进程的状态改为就绪状态，等待调度程序调度。阻塞进程自己唤醒自己，只能由其他进程执行唤醒原语把其唤醒。因为被阻塞的进程不参与CPU调度，不能执行任何语句。

(5) 挂起原语。进程运行过程中出现挂起事件时，系统调用挂起原语把进程变为挂起 态。如原进程处于活动就绪态则变为挂起就绪；若处于阻塞态，则修改为挂起阻塞态。被挂 起进程的非常驻部分要从内存移到磁盘对换区，释放出宝贵内存资源。挂起原语既可由进 程自己调用也可由其他进程调用。

(6) 激活原语。当激活进程的事件发生时，例如父进程或用户进程请求激活某指定进 程，此时内存中若有足够空间，系统调用激活原语将指定进程激活，把外存上的静止态进程 换入内存。激活原语检査被激活进程的状态，若是静止就绪便将之改为活动就绪;若为静止 阻塞，便将之改为活动阻塞。激活原语一般只能由其他进程调用，进程自己不能激活自己。

![image-20230917221610855](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230917221610855.png)

## 2.4进程通信IPC

- 共享存储
  - 基于数据结构的共享
  - 基于存储区的共享
- 消息传递
  - 直接通信
  - 间接通信
- 管道通信

进程通信是指两个进程之间发生数据交互

如果两块进程能够随意的访问地址空间，就会导致内存读写不安全。各进程拥有独立的内存地址空间，而想要进程通信就需要有操作系统的支持。

### 共享存储

两个进程想要通信，内存中需要有一块共享存储区，A进程先将需要共享的数据读出来，然后写入共享存储区，B进程从共享存储区中读取要共享的数据，再在自己的进程当中使用这些数据。这样就可以实现共享存储。

但是这种方式有种弊端，就是两个进程同时写入数据，有可能导致数据覆盖的问题。

为了避免这种问题，各个进程对共享存储区是互斥访问的，各个进程可以使用操作系统内核提供的同步互斥工具。（P、V操作）

![image-20230920110937258](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920110937258.png)

共享存储有两种方式：一种是基于数据结构的共享，这种方式速度慢，限制多，是一种低级的通信方式。一种是基于存储区的共享，操作系统在内存中画出一块共享存储块，数据的形式，存放地址都由通信进程控制，而不是操作系统，这种方式速度快，是一种高级的通信方式。

### 消息传递

进程间的数据交换以**格式化的消息**为单位，进程通过操作系统提供的发送消息/接受消息 两个原语进行数据交换。

消息传递有两种方式：一种是直接通信方式，一种是间接通信方式。

直接通信方式：消息发送进程会指明发送进程ID，接收进程ID，消息长度等格式化起来的消息。

间接通信方式：通过“信箱”间接的通信。也叫信箱通信

![image-20230920113123947](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920113123947.png)

1. 进程P想将自己要发送的消息体进行一层包装，消息头中指明发送进程ID和接收进程ID
2. 然后调用操作系统内核提供的发送原语，传递给原语的参数有接收进程的地址和消息内容
3. 调用发送原语之后，会将进程P中要发送的内容复制一份给进程Q的消息队列进行排队
4. 进程Q调用接收原语，然后遍历消息队列，找到进程P的消息，并将消息复制到进程Q来使用

![image-20230920114344598](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920114344598.png)

1. 进程P先将自己发送的消息进行包装，填写消息头
2. 操作系统中会有信箱专门用来存放消息，进程P发送原语，往信箱A中发送消息
3. 进程Q接收原语，并将消息体复制到自己的内存空间

### 管道通信

管道是一个特殊的共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的内存缓冲区。

管道通信和共享存储的区别：

管道通信是一个pipe文件，遵循先进先出的一个读写顺序，就是一个循环队列，而共享存储没有这样的限制随机读写。



1. 管道只能采用半双工通信，就是说同一时刻只能单向传输，如果要实现全双工通信，就需要两个管道。
2. 各进程要互斥的访问管道（由操作系统实现）。
3. 当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。
4. 当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。
5. 管道中的数据一旦被读出，就彻底消失，因此，当多个进程读同一个管道时，可能会错乱。对此，有两种解决方案：①一个管道允许多个写进程，一个读进程。②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读取。（Linux的方案）

![image-20230920140537936](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920140537936.png)

## 2.5线程

进程是程序的一次执行，但是一个程序的很多功能显然不可能是顺序处理就能实现的。

有的进程可能需要同时做很多事，而传统的进程只能串行的执行一系列程序，为此，引入了线程，来增加并发度。

传统的进程是程序执行流的最小单位，而引入了线程之后，线程成为了程序执行流的最小单位。

线程是一个基本的CPU执行单元，也是程序执行流的最小单位。

引入线程之后，不仅是进程之间可以并发，线程之间也可以并发执行，从而提高了系统的并发度，一个进程内亦可以并发处理各种任务。

引入线程后，进程只作为除CPU之外的系统资源的分配单元。



![image-20230920142836767](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920142836767.png)

![image-20230920142938782](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920142938782.png)

### 线程的实现方式

#### 用户级线程

用户级线程是通过应用程序中的代码实现线程库来实现的。所有的线程管理都由应用程序负责，用户级线程中，线程切换可以在用户态下完成，无需操作系统干预。操作系统意识不到线程的存在，用户可以感知到多线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换核心态，线程管理的系统开销小，效率高

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程并不能在多核处理机上并发运行。

![image-20230920144014137](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920144014137.png)

#### 内核级线程

![image-20230920145114625](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920145114625.png)

#### 多线程模型

一对一模型

![image-20230920145542089](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920145542089.png)

多对一模型

![image-20230920145558580](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920145558580.png)

多对多模型

![image-20230920145655639](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920145655639.png)

![image-20230920145356689](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920145356689.png)

### 线程的状态与转换

![image-20230920150105611](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920150105611.png)

#### 线程TCB数据结构

![image-20230920150137159](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920150137159.png)

## 2.6调度

### 调度的概念

当有一堆任务要处理，由于资源有限，这些事情没法同时处理，需要确定某种规则来决定这些任务的执行顺序。

调度的三个层次--高级调度（作业调度）：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程，每个作业之调入一次，调出一次，作业调入时建立PCB，调出时撤掉PCB

调度的三个层次--低级调度（进程调度/处理机调度）：按照某种调度策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。

调度的三个层次--中级调度（内存调度）：内存不够时，可将某些进程的数据调出外存，等内存空闲时或者进程需要运行时再重新调如内存。暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。中级调度（内存调度）就是按照某种调度策略决定将哪个处于挂起状态的进程重新调入内存。

调度频率：低级调度>中级调度>高级调度

![image-20230920155226558](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920155226558.png)



#### 三层调度的对比

![image-20230920155331632](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920155331632.png)



![image-20230920155427831](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920155427831.png)

### 进程调度的时机、切换与过程、方式

![image-20230920160120402](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920160120402.png)

进程在操作系统内核程序临界区中不能进行调度与切换

**临界资源**：一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源

**临界区**：访问临界资源的那段代码。

进程调度的方式：

非剥夺调度方式：只允许进程主动放弃处理机，在运行过程中，即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程中止，或主动要求进入阻塞。无法及时处理紧急任务。

剥夺调度方式：当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的任务。可以有限处理紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）适合分时操作系统、实时操作系统。

进程的切换和过程：

![image-20230920163737895](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920163737895.png)



![image-20230920163823847](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920163823847.png)



### 调度程序

![image-20230920164142098](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920164142098.png)



![image-20230920164303520](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920164303520.png)

### 调度算法的评价指标

#### CPU利用率

指cpu忙碌的时间占总时间的比例

利用率=忙碌的时间/总时间

#### 系统吞吐量

单位时间内完成作业的数量

系统吞吐量=总共完成了多少道作业/总共花了多少时间



#### 周转时间

是指从作业被提交给系统开始，到作业完成为止的这段时间间隔

作业周转时间=作业完成时间 - 作业提交时间

平均周转时间=各作业周转时间总和/作业数

带权周转时间=作业周转时间/作业实际运行的时间

带权周转时间必然大于1，越小越好。

平均带权周转时间=各作业带权周转时间之和/作业数

#### 等待时间

指作业处于等待处理机状态时间之和

![image-20230920165912656](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920165912656.png)

#### 响应时间

指从用户提交请求到首次产生响应所用的时间



![image-20230920170021426](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920170021426.png)

### 调度算法

#### 先来先服务算法 FCFS

![image-20230920185032735](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920185032735.png)

#### 短作业优先算法

![image-20230920185420637](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920185420637.png)



![image-20230920185642516](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920185642516.png)

![image-20230920190040346](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920190040346.png)



#### 高响应比优先算法

![image-20230920190416756](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920190416756.png)



![image-20230920190510628](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920190510628.png)

#### 时间片轮转算法

![image-20230920191214937](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920191214937.png)

![image-20230920191527704](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920191527704.png)

![image-20230920191620648](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920191620648.png)

#### 优先级调度算法

![image-20230920191813853](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920191813853.png)

![image-20230920191958247](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920191958247.png)

![image-20230920192241254](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920192241254.png)

![image-20230920192322732](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920192322732.png)

#### 多级反馈队列调度算法

![image-20230920192717531](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920192717531.png)



![image-20230920192920476](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920192920476.png)



#### 多级队列调度算法

![image-20230920193323858](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920193323858.png)

## 2.7进程同步

### 进程同步 进程互斥基本概念

进程具有异步性的特征，异步性是指，各并发执行的进程以各自独立的不可预知的速度向前推进。

同步也称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系，进程间的直接制约关系就是源于他们的相互合作。



> 把一个时间段内只允许一个进程使用的资源称为临界资源



![image-20230920210814131](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920210814131.png)

互斥访问遵循原则：

![image-20230920210928531](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920210928531.png)

![image-20230920211051054](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920211051054.png)

### 进程互斥的软件实现方法

例子：两个进程访问打印机

![image-20230920211507568](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920211507568.png)

#### 单标志法

![image-20230920212046721](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920212046721.png)



缺点：**只能轮流访问**，如果此时turn表示为1，但是P1进程一直不使用临界资源，那么turn就无法变为0，P0进程就无法使用，即使**临界区空闲，这样违背了空闲让进**的原则。

#### 双标志先检查法

检查和上锁不能一气呵成

![image-20230920212910022](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920212910022.png)

#### 双标志后检查法

![image-20230920213113304](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920213113304.png)

#### Peterson算法

![image-20230920213749504](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920213749504.png)

缺点：

![image-20230920213946857](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920213946857.png)



![image-20230920220816290](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230920220816290.png)

### 进程互斥的硬件实现方法

#### 中断屏蔽方法

利用开关中断指令实现，优点是简单高效，缺点是不适用与多处理机，只适用于操作系统内核进程，不适用于用户进程，因为开关中断指令只能运行在内核态，而且不能发生进程切换。

#### TestAndSet指令

TS指令 TestAndSetLock TSL指令

![image-20230921144549372](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921144549372.png)



#### swap指令

![image-20230921144755160](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921144755160.png)

![image-20230921144808530](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921144808530.png)

### 互斥锁



![image-20230921145542133](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921145542133.png)

适用于多处理机系统，即使一个核自旋等待，也不会占用太长时间

![image-20230921151459778](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921151459778.png)

### 信号量机制

信号量是一个变量，有两种类型，一种整形信号量，一种记录型信号量，用信号量来表示系统中某种资源的数量。

原语执行一气呵成，不可中断。由关中断开中断指令实现。

一对原语：wait(S)  signal(S) 两个原语，简称为P、V操作，P(S) 、V(S) （荷兰语proberen、verhogen）

#### 整形信号量

![image-20230921153313491](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921153313491.png)

#### 记录型信号量

![image-20230921153758316](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921153758316.png)

![image-20230921154155017](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921154155017.png)



![image-20230921154355825](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921154355825.png)



![image-20230921154629908](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921154629908.png)



### 信号量机制实现进程互斥、同步

#### 信号量机制实现进程互斥

![image-20230921155111545](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921155111545.png)

#### 信号量机制实现进程同步

![image-20230921155528774](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921155528774.png)



#### 信号量机制实现前驱关系

![image-20230921155751520](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921155751520.png)

![image-20230921155906014](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921155906014.png)

### 使用信号量机制解决问题

#### 生产者消费者问题

问题分析：

![image-20230921160547011](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921160547011.png)

![image-20230921160644511](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921160644511.png)

如何实现

![image-20230921161855136](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921161855136.png)



```java
使用Java代码来实现生产者消费者问题
使用一个整型变量来表示缓冲区容量大小。
    clerk类同时实现了produce()方法和consumer()方法
/**
 * 线程通信的应用：经典例题：生产者/消费者问题
 *
 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，
 * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，
 * 店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；
 * 如果店中没有产品了，店员会告诉消费者等一下，
 * 如果店中有产品了再通知消费者来取走产品。
 *
 * 分析：
 *      1.是否是多线程的问题？是，生产者的线程，消费者的线程
 *      2.是否有共享数据的问题？是，店员、产品、产品数
 *      3.如何解决线程的安全问题？同步机制，有三种方法
 *      4.是否涉及线程的通信？是
 */

class Clerk{

    private int productCount = 0;

    //生产产品
    public synchronized void produceProduct() {

        if(productCount < 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + ": 开始生产第" + productCount + "个产品");

            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    //消费产品
    public synchronized void consumeProduct() {

        if(productCount > 0){
            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");
            productCount--;

            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}

class Producer extends Thread{//生产者
    private Clerk clerk;

    public Producer(Clerk clerk){
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + ": 开始生产产品......");

        while(true){

            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.produceProduct();
        }
    }
}

class Consumer extends Thread{  //消费者
    private Clerk clerk;

    public Consumer(Clerk clerk){
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + ": 开始消费产品......");

        while(true){

            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.consumeProduct();
        }

    }
}

public class ProductTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");
        Consumer c2 = new Consumer(clerk);
        c2.setName("消费者2");

        p1.start();
        c1.start();
        c2.start();
    }
}			
```

死锁问题

![image-20230921165238266](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921165238266.png)

#### 多生产者多消费者问题

问题描述

![image-20230921200153500](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921200153500.png)

问题分析

![image-20230921200654092](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921200654092.png)

实现

![image-20230921201211103](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921201211103.png)



缓冲区大小为1，可以不设置mutex互斥变量

![image-20230921201405674](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921201405674.png)

#### 吸烟者问题

问题描述

![image-20230921201741651](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921201741651.png)

问题分析

![image-20230921202037563](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921202037563.png)

实现

![image-20230921202243084](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921202243084.png)

总结和思考

![image-20230921202350100](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921202350100.png)



#### 读者写者问题

问题描述

![image-20230921202800145](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921202800145.png)

问题分析

![image-20230921202854318](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921202854318.png)

实现

![image-20230921203405051](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921203405051.png)

优化

![image-20230921203643311](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921203643311.png)

总结和思考

![image-20230921203838699](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921203838699.png)

#### 哲学家进餐问题

问题描述

![image-20230921204131738](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921204131738.png)

死锁问题产生

![image-20230921204313798](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921204313798.png)

两种解决方案

![image-20230921204513282](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921204513282.png)

第三种解决方案

![image-20230921204930481](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921204930481.png)

总结和思考

![image-20230921205028786](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230921205028786.png)

### 管程

为什么要引入管程？

因为信号量机制编写困难、易出错，需要着重把握PV操作的顺序，使用不当容易造成死锁



> 定义：利用共享数据结构抽象的表示系统中的共享资源，并对外开放对该数据结构的操作函数，将信号量和原语操作封装在一个对象内部，使用时可忽略管程内部的实现细节，减轻编程负担。

类似于面向对象中的封装思想

基本特征：

1. 局部与管程的数据只能被局部于管程的过程（函数）所访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程

使用管程解决生产者消费者问题：

![image-20230924190216618](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924190216618.png)

#### Java中类似于管程的机制

使用关键字synchronized来描述一个函数，这个函数同一时间段内只能被一个线程调用

```java
public synchronized void insert(Item item){

}
```



![image-20230924191007170](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924191007170.png)

#### 使用Java实现管程

```java
//在Java中，可以使用synchronized关键字配合wait()和notify()方法实现管程模型，解决生产者消费者问题。

//首先，我们需要创建一个共享缓冲区，用于生产者将数据放入，消费者从中取出数据。可以使用一个数组表示缓冲区，以及两个指针in和out分别指向缓冲区的下一个可用位置和下一个待取出位置。
public class Buffer {
    private Object[] buffer;
    private int maxSize;
    private int in;
    private int out;
    private int count;

    public Buffer(int maxSize) {
        this.maxSize = maxSize;
        buffer = new Object[maxSize];
        in = 0;
        out = 0;
        count = 0;
    }

    public synchronized void produce(Object item) throwsInterruptedException{
        while (count == maxSize) {
            wait();  // 缓冲区已满，生产者需要等待
        }
        buffer[in] = item;
        in = (in + 1) % maxSize;
        count++;
        notifyAll();  // 唤醒可能正在等待的消费者
    }

    public synchronized Object consume() throws InterruptedException {
        while (count == 0) {
            wait();  // 缓冲区为空，消费者需要等待
        }
        Object item = buffer[out];
        out = (out + 1) % maxSize;
        count--;
        notifyAll();  // 唤醒可能正在等待的生产者
        return item;
    }
}

//我们可以创建生产者和消费者线程，分别调用produce()和consume()方法进行生产和消费。
public class ProducerConsumer {
    public static void main(String[] args) {
        Buffer buffer = new Buffer(10);

        Thread producerThread = new Thread(() -> {
            try {
                for (int i = 0; i < 20; i++) {
                    buffer.produce("Item " + i);
                    System.out.println("Produced: Item " + i);
                    Thread.sleep((long) (Math.random() * 1000));
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        Thread consumerThread = new Thread(() -> {
            try {
                for (int i = 0; i < 20; i++) {
                    Object item = buffer.consume();
                    System.out.println("Consumed: " + item);
                    Thread.sleep((long) (Math.random() * 1000));
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        producerThread.start();
        consumerThread.start();
    }
}
```





## 2.8死锁

### 死锁的概念

> 定义：是指一组并发执行的进程彼此等待对方释放资源，而在没有得到对方占有的资源之前不释放自己占有的资源，导致彼此都不能向前推进，称该组进程发生了死锁



#### 死锁、饥饿、死循环的区别

死锁：各进程互相等待对方手里的资源，导致**各进程**都阻塞无法向前推进的现象。

饥饿：由于长期得不到想要的资源，**某进程**无法向前推进的现象

死循环：某进程执行过程中一直跳不出某个循环的现象，有时是因为程序逻辑的问题，有时是程序员故意设计的。

![image-20230924193629059](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924193629059.png)

#### 死锁产生的必要条件

1. 互斥条件：只有对必须互斥使用的资源的争抢才会发生死锁
2. 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
3. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
4. 循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程请求。

发生死锁一定有循环等待，但是发生循环等待不一定死锁。循环等待是死锁的必要不充分条件。

#### 什么时候会发生死锁？

1. 对系统资源的竞争。
2. 进程推进顺序非法
3. 信号量使用不当

#### 死锁的处理策略

1. 预防死锁，破坏产生死锁的四个必要条件中的一个或几个
2. 避免死锁，用某种方法防止系统进入不安全状态，（银行家算法）
3. 死锁的检测和接触，允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。



![image-20230924195507763](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924195507763.png)



### 死锁的处理策略--预防死锁

#### 破坏互斥条件

把只能互斥使用的资源改造为允许共享使用，比如spooling技术。缺点是并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性，因此很多时候无法破坏互斥条件。



#### 破坏不剥夺条件

方案一：当某个进程请求新的资源得不到满足时，他必须立即释放保持的所有资源，待以后需要在重新申请。

方案二：当某个进程需要的资源被其他进程所占用的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。

缺点：

1. 实现起来复杂
2. 释放以获得资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和易恢复状态的资源，如CPU。
3. 反复的申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都要放弃，以后再重新申请，如果一直发生这样的情况，就会导致进程饥饿。

#### 破坏请求和保持条件

可以采用静态分配方法：进程在运行前一次申请完它所需要的全部资源，在它的资源为满足前，不让它投入运行。一旦投入运行后，这些资源就一直归他所有，该进程就不会再请求别的任何资源了。

缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低，另外该策略也有可能导致进程饥饿。

#### 破坏循环等待链

可采用顺序资源分配法：首先给系统中的资源编号，规定每个进程中必须按编号递增的顺序请求资源，同类资源一次申请完。

一个进程只有已占有小编号的资源才能申请大编号资源，不可能拥有大编号资源申请小编号资源。

缺点：

1. 不方便增加新的设备，因为可能需要重新分配所有的编号
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
3. 必须按规定次序申请资源



![image-20230924202736834](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924202736834.png)



### 死锁的处理策略--避免死锁

#### 安全序列

![image-20230924210113553](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924210113553.png)



#### 安全序列、不安全状态、死锁的联系

安全序列：指如果系统按照序列分配资源，则每个进程都能顺利进行，只要能找出一个安全序列，系统就是安全状态，安全序列可能由多个。

如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。意味着之后可能所有进程都无法顺利的执行下去。如果由进程提前归还了一些资源，那么系统有可能重新回到安全状态。

如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁。

因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配。这是银行家算法的核心思想。



#### 银行家算法

![image-20230924211151098](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924211151098.png)

![image-20230924212541043](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924212541043.png)



![image-20230924212705427](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924212705427.png)



代码实现

![image-20230924213310142](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924213310142.png)



![image-20230924213448904](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924213448904.png)

### 死锁的处理策略--检测和解除

#### 死锁的检测

![image-20230924214910049](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924214910049.png)





![image-20230924215840588](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924215840588.png)



![image-20230924220141065](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924220141065.png)

#### 死锁的解除

![image-20230924222535111](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924222535111.png)



![image-20230924222642355](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230924222642355.png)

# 第三章节 内存

## 3.1内存的基础知识

### 定义

> 内存定义：内存可存放数据，程序执行前需要先放到内存中才能被CPU处理，内存是为了缓和CPU与硬盘之间的速度矛盾，就类似于cache是为了缓和CPU和内存之间的速度矛盾一样的道理。

内存中有一个一个的存储单元，这些存储单元被编址，一个地址对应一个存储单元，一个存储单元中具体还包含了二进制比特位，根据计算机不同，有的计算机按字节编址，那么每个内存单元就是八个比特位，有的计算机按字长为16位编址、32位、64位。

### 数量单位

```
2的十次方 = 1K （千）
2的二十次方 = 1M  （兆、百万）
2的三十次方 = 1G  （十亿，千兆）

```



程序经过编译链接后生成的指令中指明的是逻辑地址（相对地址），即：相对与进程的起始地址而言的地址。

### 地址转换：如何将指令中的逻辑地址转换为物理地址

策略：三种装入方式

1. 绝对装入
2. 可重定位装入（静态重定位）
3. 动态运行时装入（动态重定位）

#### 装入的三种方式--绝对装入

在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存。

绝对装入只适用于单道程序环境中，灵活性差。

#### 装入的三种方式--可重定位装入

静态重定位：编译连接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入内存的适当位置，装入时对地址进行重定位，将逻辑地址变换为物理地址。

静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，而且必须时连续的内存空间。如果没有足够的内存，就不能装入改作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。

#### 装入的三种方式--动态运行时装入

动态重定位：编译链接后的装入模块的地址都是从0开始的，装入程序吧装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正执行时才进行，因此装入内存后所有的地址依然是逻辑地址，这种方式需要一个重定位寄存器的支持。

重定位寄存器用来存放装入模块存放的起始位置，然后将逻辑地址与起始地址相加，得到最终的存放地址，采用动态重定位时允许程序在内存中发生移动。

优点：可将程序分配到不连续的存储区中，根据需要动态申请分配内存，便于程序段的共享。

#### 从写程序到程序运行

![image-20230925191458953](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925191458953.png)

#### 链接的三种方式

![image-20230925191940259](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925191940259.png)

知识回顾

![image-20230925192013633](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925192013633.png)

## 3.2内存管理

1. 操作系统负责内存空间的分配和回收
2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充
3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与绝对地址的转换，（三种方式：绝对、静态、动态）
4. 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。



操作系统要怎么记录那些内存区域已被分配出去？哪些又还空闲？

很多位置都可以存放，到底应该存放在哪里？

当进程运行结束之后，如何将进程占用的内存空间回收？



### 内存保护的两种方式

1. 上下限寄存器，两个寄存器用来存放进程的上下限地址，进程的指令要访问某个地址时，CPU检查是否越界。
2. 采用重定位寄存器和界地址寄存器，进行越界检查，重定位寄存器中存放的是起始物理地址，界地址寄存器存放最大逻辑地址。先和界地址存放的逻辑地址比较，如果没有超过，就和重定位中保存的起始物理地址相加，得到最终的物理存储单元。



![image-20230925194048404](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925194048404.png)

### 内存空间的扩充技术

**覆盖技术**

将程序分为多个模块，常用的段常驻内存，不常用的段在需要时调入内存

内存中分为一个固定区，若干个覆盖区

需要常驻内存的段放入固定区，调入后不再调出，除非运行结束。

不常用的段放在覆盖区，需要时调入



![image-20230925200643690](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925200643690.png)

**交换技术**

当内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中已经具备运行条件的进程换入内存。

![image-20230925201457232](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925201457232.png)



![image-20230925201511468](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925201511468.png)

### 内存空间的分配与回收

### 连续分配管理方式

**单一连续分配方式**

![image-20230925202100265](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925202100265.png)

**固定分区分配方式**

![image-20230925202507456](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925202507456.png)



![image-20230925202557043](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925202557043.png)



**动态分区分配**

动态分区分配不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。

1、系统要用什么样的数据结构记录内存的使用情况？

两种常用的数据结构：空闲分区表和空闲分区链

空闲分区表：每个空闲分区对应一个表项，表项中包含了分区号，分区大小，起始地址，状态

空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针，起始部分出还可记录分区大小等信息

2、当很多空闲分区都能满足需求时，应该选择哪个分区进行分配？

**动态分区分配算法**



3、如何进行分区的分配与回收？

假设采用空闲分区表，如何分配？

如果分配空间大小小于空闲空间大小，则会在空闲分区表中减去分配空间大小，修改表中的数据

如果正好相同，则会删掉这条空闲分区的记录

如何回收？

如果回收区的后面有一个相邻的空闲分区，那么两个相邻的空闲分区合并为一个，并且更新空闲分区表中的分区大小和起始地址等信息

如果回收区的前面有一个相邻的空闲分区，那么同样的合二为一

如果回收区的前后各有一个相邻的空闲分区 ，空闲分区中原本的两个空闲分区加上回收区合并为一个

如果前后都没有相邻的空闲分区，需要在空闲分区表中加一条记录



**内部碎片和外部碎片**

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上

外部碎片：是指内存中的某些空闲分区由于太小而难以利用

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些碎片不能满足进程的需求，可以通过紧凑技术来解决外部碎片。

![image-20230925233246622](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230925233246622.png)

### 动态分区分配算法

首次适应算法：每次都从低地址开始查找，找到第一个能满足大小的空闲分区，空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链或空闲分区表，找到大小能满足要求的第一个空闲分区。

最佳适应算法：由于动态分区分配是一种连续分配方式，为进程分配的空间必须是连续的一整块区域，因此为了保证当大进程到来时能够有连续的大片空间，可以尽可能留下大片空闲区，也就是优先使用更小的空闲区。

实现：空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链（表），找到大小能满足要求的第一个空闲分区。

缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的难以利用的内存块，因此这种方法会产生很多的外部碎片。

最坏适用算法：

也叫最大适应算法，是为了解决最佳适应算法过多外部碎片的问题，空闲分区按容量递减的次序链接，每次分配内存时顺序查找空闲分区链，找到大小能满足的要求的第一个空闲分区。

缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，但是大进程到来时，没有内存分区可用了。

邻近适应算法：首次适应算法每次都从头开始查找，可能导致低地址部分出现很多很小的空闲分区，而且每次从头开始查找都会增加查找的开销，所以采用循环链表，从上次查找结束的位置开始查找空闲分区链，找到大小能满足的第一个分区。而且不需要对链表进行重新排列

缺点是无论低地址还是高地址都有相同的概率被使用，那么高地址的大分区更可能被使用，划分为小分区，最后没有大分区可用。

总和来看，首次适应算法的效果反而更好。

![image-20230926002227559](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926002227559.png)



### 非连续分配管理方式

非连续分配：为用户进程分配的可以是一些分散的内存空间

![image-20230926204551119](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926204551119.png)



![image-20230926204728340](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926204728340.png)



![image-20230926205240099](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926205240099.png)



![image-20230926205403849](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926205403849.png)

![image-20230926205704046](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926205704046.png)



![image-20230926210657109](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926210657109.png)

![image-20230926210746069](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926210746069.png)



#### 基本地址变换机构

![image-20230926211517062](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926211517062.png)

![image-20230926211247064](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926211247064.png)

![image-20230926211722036](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926211722036.png)

![image-20230926212000936](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926212000936.png)

### 具有快表的地址变换机构

![image-20230926212619435](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926212619435.png)



![image-20230926220131227](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926220131227.png)



![image-20230926230251933](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230926230251933.png)

### 两级页表

![image-20230927091425421](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927091425421.png)

![image-20230927091531247](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927091531247.png)



### 基本分段存储管理方式

![image-20230927091947310](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927091947310.png)



![image-20230927092556611](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927092556611.png)

![image-20230927093013126](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927093013126.png)



![image-20230927093401896](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927093401896.png)

![image-20230927093532107](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927093532107.png)



![image-20230927093718434](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927093718434.png)

![image-20230927093809702](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927093809702.png)

### 段页式管理方式

![image-20230927103225485](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927103225485.png)



![image-20230927104200404](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927104200404.png)



![image-20230927104334565](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927104334565.png)

### 虚拟内存

![image-20230927104727335](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927104727335.png)

![image-20230927104850005](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927104850005.png)



![image-20230927105222559](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927105222559.png)



![image-20230927105251753](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927105251753.png)



#### 请求分页管理方式

![image-20230927105544837](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927105544837.png)



![image-20230927105821411](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927105821411.png)

![image-20230927110323533](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927110323533.png)



![image-20230927110336000](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927110336000.png)

#### 页面置换算法

![image-20230927110728824](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927110728824.png)



![image-20230927111151198](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927111151198.png)



![image-20230927111410353](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927111410353.png)



![image-20230927111603144](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927111603144.png)



![image-20230927111854861](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927111854861.png)



![image-20230927112230736](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927112230736.png)

#### 页面分配策略

![image-20230927180635201](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927180635201.png)



#### 内存映射文件

![image-20230927181540403](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230927181540403.png)





# 第四章节 文件管理

## 4.1文件的基本概念

定义：文件是由文件名标识的、存储在外部存储介质上的一组相关信息的集合。文件通常作为一个独立单位存放并实施相应的操作。

文件的属性：标识符、 类型、 长度、 时间、位置、存取控制权限、文件拥有者。

文件分为有结构文件和无结构文件两种。

**有结构文件**中，文件由若干个相关记录组成。 记录是一些相关数据项的集合，数据项是数据组织中可以命名的最小逻辑单位。

**无结构文件**则被看 成是一个字符流。组成文件的信息可以是各式各样的

文件系统的基本功能：

1. 存储空间的分配和管理
2. 文件管理
3. 目录管理
4. 文件共享
5. 文件保护和加密
6. 提供用户接口

### 文件的逻辑结构

文件的逻辑结构：

- 无结构文件
- 有结构文件
  - 顺序文件
  - 索引文件
  - 索引顺序文件



**无结构文件**：流式文件，文件内部数据是一系列二进制流或字符流组成。

**有结构文件**：记录式文件，每条记录由若干数据项组成，根据每条数据记录的长度是否相等，分为定长记录文件和可变长记录文件。

**顺序文件**：文件中的记录一个接一个的顺序排列，记录可以是定长的或可变长的，各个记录在物理上可以是顺序存储，或链式存储。

如果是链式存储，无论是可变长或定长记录，都无法实现随机存取，每次只能遍历。

如果是顺序存储的可变长记录，无法实现随机存取，每次只能遍历。

如果是顺序存储的定长记录，可实现随机存取，若采用串结构，无法快速找到某关键字对应的记录。顺序结构可以快速找到关键字对应的记录。

**索引文件**：对于可变长记录文件，必须要找到i-1条记录才能找到第i条记录，但是很多场景中必须是可变长记录。引入了索引表，每条记录对应一个索引项。索引表本身是定长记录的顺序文件，可以快速找到第i个记录对应的索引项。可将关键字作为索引号。

**索引顺序文件**：索引文件的缺点是索引表可能比文件内容本身占用内存还要大，空间利用率低。索引顺序文件是将索引文件和顺序文件思想结合，同样会为文件建立一张索引表，但并不是为每条记录对应一个索引项，而是一组记录对应一个索引表项。索引顺序文件的索引项也不需要用关键字顺序排列，方便新表项插入。但是又有新的问题？能否解决不定长记录顺序文件检索速度慢的问题？

**多级索引顺序文件**：为了进一步提高检索效率，为顺序文件建立多级索引表，例如，对于一个含10的6次方记录的文件，先建立一张低级索引表，每100个记录为一组，总共一万个表项，再把一万个表项分组，100个记录一组，建立顶级索引表，100项索引。类似套娃。



### 文件目录

知识概览

![image-20230929105547214](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230929105547214.png)





**文件控制块：**每一个文件在文件目录中登记一项，作为文件系统建立和维护文件的清单。每个文件的文件目录项又称为文件控制块（File Control Block, FCB）。从操作系统管理角度看待文件，文件由文件控制块和文件体组成。文件控制块包含文件的基本信息、存取控制信息和文件使用信息。

**单极目录结构**：早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占用一个目录项，单机目录按名存取，不允许文件重名，不适用与多用户OS，不同用户可能由重名文件。

**两级目录结构**：早期的多用户操作系统，采用两级目录结构，分为主文件目录MFD，和用户目录结构UFD，主文件目录记录用户名及相应用户文件目录的存放位置，两级目录结构允许不同用户文件重名，也可以在目录上实现访问限制，检查此时登录的用户名是否匹配，但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。

**多级目录结构**：多级目录结构常又称树型目录结构。其中，主文件目录称为根目录，数据文件称为树叶结点，其他文件目录作为树内结点。从根目录出发的路径是绝对路径，从当前目录出发的相对路径，使用相对路径可以减少磁盘IO操作。

![树形目录结构](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001101126615.png)

**无环图目录结构**：树型目录结构便于实现文件的分类和查找，但不便于实现文件共享。在多道程序并发执行系统中，经常会出现不同用户进程以不同的名字访问同一个文件。如果在树型目录结构中达到这个要求，就必须生成两份相同文件拷贝，既浪费了存储空间，也不利于保证拷贝的一致性。为此，引入了便于实现文件共享的无环图目录结构。无环图目录结构允许若干目录共同描述或共同指向被共享的子目录或文件。

![无环图目录结构](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001101853755.png)

**索引节点**：FCB的瘦身，在查找各级目录的过程中，只需要用到文件名这个信息，只有文件名匹配时，才需要读出其他信息，因此瘦身。

一张索引表中，文件名作为一列，除了文件名的其他信息都用索引节点指针存放地址，索引节点指针作为一列。



### 文件分配方式

文件分配方式是对非空闲磁盘块的管理

而文件存储空间管理是对空闲磁盘块的管理

![image-20230929111850373](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20230929111850373.png)

### 文件存储空间管理

知识概览

![image-20231001145421848](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001145421848.png)

存储空间的划分和初始化

![image-20231001105933743](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001105933743.png)



存储空间管理--空闲表法

![image-20231001110421146](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001110421146.png)

存储空间管理--空闲链表法

![image-20231001110823146](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001110823146.png)

空闲盘块链

![image-20231001111114166](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001111114166.png)

空闲盘区链

![image-20231001111333642](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001111333642.png)

存储空间管理--位示图法

![image-20231001112118030](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001112118030.png)

分配与回收

![image-20231001112313961](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001112313961.png)

存储空间管理--成组链接法

![image-20231001112502194](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001112502194.png)

图示

![image-20231001113022254](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001113022254.png)

超级块中首先记录的是下一组空闲盘块数，之后记录的是那些空闲块号，而300盘块作为这一组的第一个盘块，他还会记录下一个空闲磁盘块的空闲盘块数和空闲块号，这样依次往下，直到最后的下一组没有空闲磁盘块之后，就会把原先记录第一个盘块的地方设为-1，其余只记录空闲块号，最后一组就没有超级块只有空闲盘块了。

如何分配？

先检查每个分组的块数是否够，如果足够的话，直接分配，并且超级块中的空闲盘块数需要减一，如果正好相等，在分配之前需要将存储的下一组空闲块的链接给复制到超级快当中，避免链接断开丢失空闲块，然后再分配空闲空间。

如何回收？

![image-20231001145336765](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001145336765.png)

### 文件基本操作

 知识概览

![image-20231001145608699](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001145608699.png)

创建文件

创建文件时，会进行create系统调用，需要提供几个主要参数：所需外存空间大小，文件存放路径，文件名，在进行create系统调用时，主要有两个步骤：1、在外存中找到文件所需空间（根据文件存储空间管理进行分配），2、根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件的目录项，目录项中包含了文件名，文件在外村中的存放位置。

删除文件

删除文件时，会进行delete系统调用，提供几个主要参数：文件存放路径，文件名，在处理delete系统调用时，主要步骤有：1、根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。2、根据该目录项记录的文件在外存的存放路径、文件大小等，回收文件占用的磁盘块（根据文件存储空间管理进行回收）。3、从目录表中删除文件对应的目录项。

打开文件

打开文件时，会进行open系统调用，提供主要参数有：文件存放路径，文件名，要对文件的操作类型如只读 读写，在进行open系统调用时，主要步骤有：1、根据文件存放路径找到相应的目录文件，从目录文件中找到文件名对应的目录项，并检查该用户是否有指定的操作权限，2、将目录项复制到内存中的打开文件表，将表中文件对应的编号返回用户，之后用户使用打开文件表的编号来指明要操作的文件，加快文件的访问速度。

系统中只有一张系统打开文件表，每个用户进程会有属于自己的打开文件表，用户进程的打开文件表中有一个字段叫做系统表索引号，指向系统打开文件表中的编号，如果有多个进程打开同一个文件，那么这几个进程的打开文件表索引号都指向系统文件表的编号，系统打开文件表中有打开计数器，记录此时有多少个进程打开此文件。如果想要删除某文件，系统就会查询系统打开文件表的此文件的打开计数器，根据计数器来决定这个文件可不可以被删除。用户进程打开文件表中还有读写指针记录读写位置，访问权限字段决定对该文件的操作权限。

关闭文件

进程使用完文件后，关闭文件，OS在处理close系统调用时，主要步骤有：1、将进程的打开文件表相应表项删除，2、回收分配给该文件的内存空间等资源，3、系统打开文件表的打开计数器count--，若count=0，删除对应表项。

读文件

进程使用read系统调用完成读操作，需要指明参数有：是哪个文件（可以在打开文件表中直接查找编号），读入多少数据，读入的数据放在内存中的位置。OS在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的文件数据读入指定区域。

写文件

写文件操作和读文件类似。

### 文件共享

知识概览

![image-20231001153337692](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001153337692.png)

硬链接

硬链接是基于文件索引节点的共享方式，索引节点是文件目录瘦身策略，由于检索文件只需用到文件名，因此可以将除了文件名之外的其他信息放到索引节点，这样目录项就只需要包含文件名、索引节点指针。

如果有两个进程访问同一个文件，那么这两个用户的目录项中的索引节点指针都指向同一个文件的索引节点，索引节点中会有一个链接技术器count，用于表示链接到本索引节点上的用户目录项数。如果某个用户决定删除文件，则只是删除用户目录项，且索引节点的count--；当count=0时OS会负责删除该文件。

软链接

软链接是基于符号链的共享方式。软链接和硬链接的索引结点不同，硬链接指向的是源文件，而软链接相当于创建了一个link型文件，这个link指向的是文件路径，即使源文件删除，link型文件依然存在，但是指向的无效地址，也就打不开这个文件了。软链接类似于WindowsOS中的快捷方式。

<img src="https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001155043865.png" alt="Windows中的快捷方式" style="zoom: 50%;" />

### 文件保护

知识概览

![image-20231001155821888](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001155821888.png)

口令保护

为文件设置一个口令，如12345678，用户访问该文件时必须提供口令，口令一般存放在FCB中或者索引结点中，用户访问文件，OS负责将用户提供的口令和FCB中存储的口令比对，正确才可访问。

优点：保存口令空间开销小，验证口令时间开销也小。

缺点：正确口令存放在系统内部，不够安全。

加密保护

使用某个密码对文件加密处理，在访问文件时，需要提供正确的密码才能解密成功看到正确的结果。例如异或加密。

优点：保密性强，不需要在系统中存储密码

缺点：编码译码或加密解密需要花费时间

访问控制

在每个文件的FCB或索引节点中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行哪些操作。如果这个访问控制表过大的话，还可以精简。方法是，以组为单位，将用户进行分组，当用户访问时，OS检查该用户所属于的分组是否有相应的访问权限。

Linux的文件权限：

![img](data:image/png;base64,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)

## 4.2文件系统层次结构

文件系统层次结构图

![文件系统层次结构图](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001162435965.png)



辅助记忆

![辅助记忆](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001162636151.png)

### 文件系统全局结构

物理格式化后：

![物理格式化后](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001163711754.png)

文件系统在外村中的结构

![文件系统在外村中的结构](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001163801889.png)

open系统调用打开文件的背后过程

![open系统调用打开文件的背后过程](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001164316085.png)

### 虚拟文件系统和文件挂载

虚拟文件系统特点：

1. 向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的差异。
2. 虚拟文件系统要求下层的文件系统必须实现某些规定的函数功能，一个新的文件系统想要在OS上被使用，就必须满足该OS的要求
3. 每打开一个文件，虚拟文件系统VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存在哪个文件系统。
4. vnode只存在主存中，inode索引结点既会被调入主存，也会在外存中存储。
5. 打开文件后，创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能。

文件系统挂载mounting，即文件系统安装或装载，如何将一个文件系统挂载在OS中，步骤：

1. 在VFS中注册新挂载的文件系统，内存中的挂载表包含每个文件系统的相关信息，包括文件系统类型，容量大小等。
2. 新挂载的文件系统，要向VFS提供一个函数地址列表
3. 将新文件系统加到挂载点，也就是将新文件系统挂载在某个父目录下



# 第五章节 设备管理

## 5.1 IO设备

### 概念和分类

IO，输入输出，input output

按使用特性分类：

- 人机交互类外部设备
- 存储设备
- 网络通信设备

按传输速率分类：

- 低速设备
- 中速设备
- 高速设备

按信息交换单位分类：

- 块设备，传输块，可寻址
- 字符设备，传输慢，不可寻址，采用中断驱动方式

### IO控制器

概念：CPU无法直接控制IO设备的机械部件，因此IO设备还要有一个电子部件作为CPU和IO设备机械部分之间的中介，用于实现CPU对设备的控制。

功能：

- 接收和识别CPU发出的命令，IO控制器中会有相应的控制寄存器来存放命令和参数。
- 向CPU报告设备的状态，IO控制器中会有相应的状态寄存器用于记录IO设备的当前状态。
- 数据交换。IO控制器中会设置相应的数据寄存器，输出时，数据寄存器用于暂存CPU发出的数据，之后再有控制器传送设备，输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。
- 地址识别。类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的地址，IO控制器通过CPU提供的地址来判断CPU要读写的是哪个寄存器。

组成：

![IO控制器的组成](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001205422384.png)

一个IO控制器可能对应多个设备，寄存器也可能有多个，且这些寄存器都要有相应的地址，才能方便IO操作，有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像IO，另一些计算机则采用IO专用地址，即寄存器独立编址。

内存映像IO和寄存器独立编址比较

![内存映像IO和寄存器独立编址比较](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001205920781.png)



### IO控制方式

IO控制方式就是说用什么样的方式来控制IO设备的数据读写。

IO控制方式有四种：

- 程序直接控制方式
- 中断驱动方式
- DMA方式
- 通道控制方式

程序直接控制方式

![程序直接控制方式](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001212130675.png)

流程图示、优缺点

![流程图示、优缺点](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001213216351.png)

中断驱动方式

![中断驱动方式](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001213822165.png)

优缺点：

![image-20231001213853623](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001213853623.png)

DMA方式

特点：

![DMA方式特点](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001214352276.png)

组成部分：

![DMA组成部分](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001214644455.png)

优缺点：

![DMA优缺点](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001214840753.png)

通道控制方式

概念和执行步骤：

![通道执行步骤](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001215216502.png)

优缺点：

![通道控制优缺点](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001215401725.png)

四种方式的总结

![四种控制方式总结](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001215433330.png)

### IO软件层次



![IO软件层次](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001221125528.png)

### 输入输出管理

输入输出应用程序接口：

- 字符设备接口
- 块设备接口
- 网络设备接口
- 概念：什么是阻塞IO/非阻塞IO?



输入输出应用程序接口

![输入输出应用程序接口](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001223319770.png)



网络设备接口socket通信过程

![网络设备接口socket](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001223236114.png)



阻塞IO和非阻塞IO

<img src="https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001223545094.png" alt="阻塞IO和非阻塞IO" style="zoom: 67%;" />

设备驱动程序接口

![设备驱动程序接口](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001223731092.png)

## 5.2 IO核心子系统

![IO核心子系统](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231001224120993.png)

### 假脱机技术

什么是脱机技术？脱机是指脱离主机的控制进行的输入输出操作。引入脱机技术后，缓解了CPU与慢速IO设备的速度矛盾，另一方面，即使CPU在忙碌，也可以提前将数据输入到磁带，即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。

假脱机技术，又叫spooling技术，使用软件的方式模拟脱机技术



![假脱机技术](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002145022108.png)

### 设备的分配与回收

设备分配的步骤

![设备分配的步骤](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002150758729.png)

缺点与改进：

![缺点与改进](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002150959617.png)

改进步骤

![改进步骤](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002151226244.png)

知识概览

![知识概览](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002151420548.png)

### 缓冲区管理

单缓冲

![单缓冲](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002153724226.png)



双缓冲

T>C+M的情况

![双缓冲 T>C+M](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002154317842.png)

T<C+M的情况

![T<C+M的情况](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002154440955.png)

总结：采用双缓冲策略，处理一个数据块的平均耗时为MAX(T,C+M)



使用单/双缓冲在通信时的区别

使用单缓冲：两个互相通信的机器只设置单缓冲，在任一时刻只能实现数据的单向传输。

使用双缓冲：两个互相通信的机器设置双缓冲，一个发送缓冲区，一个接收缓冲区，则同一时刻可以实现双向的数据传输。



循环缓冲区：将多个大小相同的缓冲区链接成一个循环队列，由两个指针来控制冲入和取出，一个in指针指向下一个可以冲入数据的空缓冲区，一个out指针指向下一个可以取出数据的满缓冲区。



缓冲池：

![缓冲池](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002155416354.png)

知识总览

![知识总览](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002155441051.png)



## 5.3 磁盘的结构

磁盘、磁道、扇区

![磁盘、磁道、扇区](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002155830700.png)



如何在磁盘中读写数据：磁头臂带动磁头移动到目标磁道，马达带动磁盘旋转到对应扇区，对应扇区划过磁道才能读写

磁盘的物理地址

![磁盘的物理地址](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002160229297.png)

磁盘的分类：

- 按磁头是否可以移动分为
  - 活动头磁盘，磁头臂可以来回伸缩带动磁头定位磁道
  - 固定头磁盘，这种磁盘每个磁道都有一个磁头，像读取哪个激活哪个磁头
- 按盘片是否可以更换分为
  - 可换盘磁盘
  - 固定盘磁盘



### 磁盘调度算法

一次磁盘读写操作需要的时间

![一次磁盘读写操作需要的时间](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002171105694.png)



先来先服务算法FCFS

![先来先服务算法FCFS](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002171330501.png)

最短寻找时间优先SSTF

![最短寻找时间优先算法SSTF](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002171736557.png)

扫描算法SCAN

![扫描算法scan](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002172309994.png)

LOOK调度算法

![LOOK调度算法](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002172458998.png)

循环扫描算法C-SCAN

![循环扫描算法C-SCAN](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002172759332.png)

C-LOOK算法

![C-LOOK算法](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002172848986.png)

知识总览

![知识总览](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002172912869.png)

### 减少磁盘延时时间的方法

磁头想要读取几块连续的扇区，当读取完第一片扇区时，磁头可能还未准备好，因此需要重新转动一圈才能到第二篇扇区，延时时间就比较大。

减少延迟方法--交替编号方法：即让逻辑上相邻的扇区在物理上有一定的间隔，比如由八个扇区，原本是01234567这样的顺序，交替编号后为04152637，如果需要读取连续的三个扇区，磁头就不需要旋转一整圈去读取了。



思考：为什么磁盘的物理地址是(柱面号，盘面号，扇区号)，而不是(盘面号，柱面号，扇区号)？

因为读取连续地址的磁盘块时，采用(柱面号，盘面号，扇区号)的地址结构可以减少磁头转动的时间。

例子：如果采用(盘面号，柱面号，扇区号)方式，想要读取0号盘面，0号柱面，八个所有扇区时，需要转两圈读完，接着再读取0号盘面1号柱面的所有扇区，需要启动磁头臂将磁头移动到下一个磁道。

而采用(柱面号，盘面号，扇区号)，当读完0号柱面0号盘面的所有扇区时，再去读取0号柱面1号盘面的所有扇区，此时只需要启动第二个盘面的磁头，而不需要启动磁头臂，这样就节省了磁头启动转动的时间。



减少延迟方法--错位命名方法：

![减少延迟方法--错位命名方法：](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002175808629.png)

### 磁盘的管理

知识总结

![知识总结](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002190144310.png)

### 固态硬盘SSD

总览

![固态硬盘SSD](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002190248341.png)

固态硬盘的结构

![固态硬盘的结构](https://raw.githubusercontent.com/DropTheChains/blog-img/main/img/image-20231002190840089.png)
